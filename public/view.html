<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Central do Técnico • Suporte_X</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
    :root{
      --brand:#FFCB19; --brandText:#111; --danger:#E63A3A; --muted:#6b7280;
      --bg:#F4F6F8; --card:#fff; --line:#E1E3E7; --blue:#0A84FF;
    }
    *{box-sizing:border-box}
    body{background:var(--bg); margin:0; font:14px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
    .grid{display:grid; grid-template-columns:360px 1fr; gap:1rem; align-items:start; padding:1.25rem}
    .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:1rem; box-shadow:0 6px 18px rgba(16,24,40,.06)}
    .title{display:flex; align-items:center; gap:.5rem}
    .dot{width:10px;height:10px;background:#22C55E;border-radius:50%}
    .muted{color:var(--muted)}
    .row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    .btn{padding:.55rem .9rem; border-radius:10px; border:1px solid var(--line); background:#fff; cursor:pointer}
    .btn.primary{background:var(--brand); color:var(--brandText); border-color:var(--brand); font-weight:600}
    .btn.outline-blue{color:var(--blue); border-color:var(--blue); background:#fff}
    .btn.danger{background:var(--danger); color:#fff; border-color:var(--danger)}
    .pill{display:inline-block; padding:.15rem .5rem; border-radius:999px; background:#EEF1F5; font-size:.85rem}
    .list{display:flex; flex-direction:column; gap:.5rem}
    .request{display:flex; justify-content:space-between; gap:.5rem; align-items:center; padding:.6rem .6rem; border:1px solid var(--line); border-radius:10px; background:#fff; overflow:visible}
    .req-meta{display:flex; flex-direction:column}
    .req-actions{display:flex !important; gap:.4rem; align-items:center}
    .req-actions .btn{display:inline-flex !important; visibility:visible !important; opacity:1 !important; pointer-events:auto !important}
    video{width:100%; max-height:70vh; background:#000; border-radius:10px}
    details summary{cursor:pointer}
    code.pill{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; background:#f3f4f6; border:1px solid #e5e7eb; padding:.1rem .35rem; border-radius:6px}
    .statusline{margin:.5rem 0 0; font-size:.95rem}
  </style>
</head>
<body>
  <div class="grid">
    <!-- ESQUERDA: FILA -->
    <aside class="card">
      <div class="title">
        <h2 style="margin:0">Central do Técnico</h2><span class="dot" title="online"></span>
      </div>
      <p class="muted" style="margin:.4rem 0 1rem 0">Solicitações aguardando aceite.</p>

      <div class="row" style="justify-content:space-between; margin-bottom:.5rem">
        <span id="queueCount" class="pill">0 pendente(s)</span>
        <button id="refresh" class="btn">Atualizar</button>
      </div>

      <div id="queue" class="list">
        <div class="muted">Nenhuma solicitação por enquanto…</div>
      </div>

      <hr style="margin:1rem 0;border:none;border-top:1px solid var(--line)">

      <details>
        <summary class="muted">Entrar manualmente (debug)</summary>
        <div class="row" style="margin-top:.5rem">
          <input id="manualRoom" type="text" placeholder="sessionId (ou room antigo)" />
          <button id="manualJoin" class="btn">Entrar</button>
        </div>
        <p class="muted" style="margin-top:.3rem">Também funciona com <code>?session=XYZ</code> ou <code>?room=123456</code> na URL.</p>
      </details>
    </aside>

    <!-- DIREITA: RTC -->
    <main class="card">
      <h1 style="margin-top:0">Atendimento</h1>

      <div class="row" style="margin-bottom:.5rem">
        <span class="muted">Sessão atual:</span>
        <code id="sessionLabel" class="pill">—</code>
      </div>

      <div class="row" style="margin:.3rem 0 .7rem 0">
        <button id="qLow"  class="btn">Qualidade: Baixa</button>
        <button id="qMid"  class="btn">Qualidade: Média</button>
        <button id="qHigh" class="btn">Qualidade: Alta</button>
        <button id="ice"   class="btn">Reiniciar ICE</button>
        <button id="stats" class="btn">Stats</button>
        <button id="stop"  class="btn danger">Parar remoto</button>
      </div>

      <video id="video" autoplay playsinline muted></video>
      <p class="muted statusline" id="status">Aguardando…</p>
    </main>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
  // ================== IDENTIFICAÇÃO
  const techName = (localStorage.getItem('techName') || prompt('Seu nome técnico?') || 'Técnico').trim();
  localStorage.setItem('techName', techName);

  // ================== UTIL
  const qs = (s) => document.querySelector(s);
  const API = ''; // mesma origem

  function getParam(name){
    const u = new URL(location.href);
    return u.searchParams.get(name) || '';
  }
  function fmtAgo(ts){
    try{
      const t = (typeof ts === 'string' && /^\d+$/.test(ts)) ? Number(ts) : Date.parse(ts) ? Date.parse(ts) : Number(ts);
      const diff = (Date.now() - t)/1000;
      if (diff < 60) return `${Math.floor(diff)}s`;
      if (diff < 3600) return `${Math.floor(diff/60)}m`;
      return `${Math.floor(diff/3600)}h`;
    }catch{ return ''; }
  }
  function setStatus(msg){ statusEl.textContent = msg; console.log('[STATUS]', msg); }
  function iceServers(){ return [{ urls: 'stun:stun.l.google.com:19302' }]; }

  // ================== ELEMENTOS
  const queueEl = qs('#queue');
  const queueCount = qs('#queueCount');
  const refreshBtn = qs('#refresh');
  const manualRoom = qs('#manualRoom');
  const manualJoin = qs('#manualJoin');

  const video = qs('#video');
  const statusEl = qs('#status');
  const sessionLabel = qs('#sessionLabel');

  const qLow = qs('#qLow'), qMid = qs('#qMid'), qHigh = qs('#qHigh');
  const iceBtn = qs('#ice'), statsBtn = qs('#stats'), stopBtn = qs('#stop');

  // reforço autoplay
  video.muted = true;
  video.addEventListener('loadedmetadata', () => video.play().catch(()=>{}));
  video.addEventListener('canplay',        () => video.play().catch(()=>{}));

  // ================== POLLING DA FILA
  async function fetchQueue(){
    try{
      const r = await fetch(`${API}/api/requests?status=queued`, { headers: { 'accept':'application/json' }});
      if(!r.ok) throw new Error('HTTP '+r.status);
      const list = await r.json();
      renderQueue(list);
    }catch(e){
      // silencioso para não incomodar o técnico
      console.debug('fetchQueue error', e);
    }
  }

  function renderQueue(items){
    queueEl.innerHTML = '';
    if(!items || !items.length){
      queueEl.innerHTML = `<div class="muted">Nenhuma solicitação por enquanto…</div>`;
      queueCount.textContent = `0 pendente(s)`;
      return;
    }
    queueCount.textContent = `${items.length} pendente(s)`;
    for(const it of items){
      const div = document.createElement('div');
      div.className = 'request';
      div.dataset.id = it.requestId;
      div.innerHTML = `
        <div class="req-meta">
          <strong>${it.brand ?? 'Dispositivo'} ${it.model ?? ''}</strong>
          <span class="muted">ID: ${it.requestId} • há ${fmtAgo(it.createdAt)}</span>
        </div>
        <div class="req-actions">
          <button class="btn outline-blue" type="button" data-act="reject" data-id="${it.requestId}">Recusar</button>
          <button class="btn primary"      type="button" data-act="accept" data-id="${it.requestId}">Aceitar</button>
        </div>`;
      queueEl.appendChild(div);
    }
  }

  async function acceptRequest(id){
    try{
      setStatus('Aceitando…');
      const r = await fetch(`${API}/api/requests/${id}/accept`, {
        method:'POST',
        headers:{'content-type':'application/json','accept':'application/json'},
        body: JSON.stringify({ techName })
      });
      if(!r.ok) throw new Error('HTTP '+r.status);
      const { sessionId } = await r.json();
      if(!sessionId) throw new Error('Sem sessionId');
      startSession(sessionId);
      fetchQueue();
    }catch(e){
      alert('Erro ao aceitar: '+e.message);
    }
  }
  async function rejectRequest(id){
    try{
      await fetch(`${API}/api/requests/${id}`, { method:'DELETE' });
      fetchQueue();
    }catch(e){}
  }

  queueEl.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button[data-act]');
    if(btn){
      const id = btn.getAttribute('data-id');
      const act = btn.getAttribute('data-act');
      if(act==='accept') acceptRequest(id);
      if(act==='reject') rejectRequest(id);
      return;
    }
    const card = ev.target.closest('.request');
    if(card && card.dataset.id){
      const id = card.dataset.id;
      card.style.opacity='0.6';
      card.style.outline='2px solid var(--brand)';
      acceptRequest(id);
    }
  });

  refreshBtn.onclick = fetchQueue;
  setInterval(fetchQueue, 2000);
  fetchQueue();

  // ================== RTC / SIGNALING
  let pc, socket, dc, transceiver;
  let currentSessionId = null;

  // fila de ICE que chegam antes da offer
  const earlyRemoteCandidates = [];
  let remoteDescSet = false;

  function resetConnectionState(){
    remoteDescSet = false;
    earlyRemoteCandidates.length = 0;
    dc = null;
    transceiver = null;
  }

  function closeCurrent(){
    try{ if(pc) pc.close(); }catch(e){}
    try{ if(socket) socket.disconnect(); }catch(e){}
    pc = null; socket = null; resetConnectionState();
  }

  function setSessionLabel(id){ sessionLabel.textContent = id || '—'; }

  function sendDc(obj){ try{ if(dc && dc.readyState==='open') dc.send(JSON.stringify(obj)); }catch(e){} }

  function preferVp8(t){
    try{
      const caps = RTCRtpReceiver.getCapabilities('video');
      if(!caps || !t.setCodecPreferences) return;
      const pref = [...caps.codecs].sort((a,b)=>{
        const rank = (c)=> c.mimeType?.toLowerCase()==='video/vp8' ? 0
                       : c.mimeType?.toLowerCase()==='video/h264' ? 1 : 2;
        return rank(a)-rank(b);
      });
      t.setCodecPreferences(pref);
    }catch(e){}
  }

  function onAnySocketEvent(ev, ...args){
    console.debug('[socket]', ev, args?.[0]);
  }

  function normalizeSdpFrom(msg){
    if(!msg) return null;
    if(typeof msg === 'string') return msg; // às vezes vem sdp pura
    if(msg.sdp) return msg.sdp;
    if(msg.offer) return msg.offer;
    if(msg.description?.sdp) return msg.description.sdp;
    if(msg.payload?.sdp) return msg.payload.sdp;
    if(msg.desc?.sdp) return msg.desc.sdp;
    return null;
  }

  async function handleOfferMessage(raw){
    try{
      const sdp = normalizeSdpFrom(raw);
      if(!sdp){ console.warn('Offer sem SDP conhecida', raw); return; }
      await pc.setRemoteDescription({ type:'offer', sdp });
      remoteDescSet = true;
      setStatus('Offer recebida. Montando answer…');

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      // enviar em formatos diferentes para compatibilidade
      const payload = { room: currentSessionId, type:'answer', sdp: answer.sdp };
      socket.emit('signal', payload);
      socket.emit('answer', { room: currentSessionId, sdp: answer.sdp, type:'answer' });
      console.debug('Answer enviada');

      // aplicar candidatos que chegaram cedo
      while(earlyRemoteCandidates.length){
        const c = earlyRemoteCandidates.shift();
        try{ await pc.addIceCandidate(c); }catch(err){ console.warn('Falha addIceCandidate (early)', err); }
      }

      setStatus('Conectado! (answer enviada)');
    }catch(e){
      console.error('Erro ao processar offer', e);
      setStatus('Erro ao processar offer');
    }
  }

  async function handleRemoteCandidate(obj){
    try{
      const c = obj?.candidate ? obj.candidate : obj; // aceita shape direto
      if(!c || (!c.candidate && c.candidate!=='')) return;

      if(!remoteDescSet){
        earlyRemoteCandidates.push(c);
        console.debug('ICE remoto guardado (antes da offer)');
      }else{
        await pc.addIceCandidate(c);
      }
    }catch(e){
      console.warn('Falha addIceCandidate', e);
    }
  }

  function wireSocketHandlers(){
    // log de tudo
    socket.onAny(onAnySocketEvent);

    const onSignal = async (msg)=>{
      try{
        const t = (msg && (msg.type || msg.kind || msg.t || msg.event)) || '';
        if((t.toLowerCase() === 'offer') || (msg.offer) || (msg.description?.type==='offer') || (msg.payload?.type==='offer')){
          await handleOfferMessage(msg);
          return;
        }
        // candidatos
        if(t.toLowerCase()==='ice' || t.toLowerCase()==='candidate' || msg.candidate || msg.ice){
          await handleRemoteCandidate(msg.candidate ? msg : (msg.ice ? msg.ice : msg));
          return;
        }
        // alguns backends mandam {sdp, type:'offer'} dentro do próprio 'signal'
        if(msg.sdp && msg.type === 'offer'){
          await handleOfferMessage(msg);
          return;
        }
      }catch(e){ console.warn('onSignal error', e); }
    };

    // eventos conhecidos
    socket.on('signal', onSignal);
    socket.on('webrtc', onSignal);
    socket.on('offer', handleOfferMessage);
    socket.on('app-offer', handleOfferMessage);
    socket.on('candidate', handleRemoteCandidate);
    socket.on('ice-candidate', handleRemoteCandidate);
    socket.on('app-candidate', handleRemoteCandidate);

    socket.on('peer-left', ()=> setStatus('Cliente encerrou o compartilhamento.'));
    socket.on('connect_error', (e)=> setStatus('Socket erro: '+e.message));
    socket.on('disconnect', (r)=> console.debug('socket disconnect', r));
  }

  async function startSession(sessionId){
    closeCurrent();
    resetConnectionState();

    currentSessionId = sessionId;
    setSessionLabel(sessionId);
    setStatus('Conectando…');

    socket = io(); // mesma origem
    wireSocketHandlers();
    socket.emit('join', sessionId);
    socket.emit('tech-hello', { room: sessionId, techName });

    pc = new RTCPeerConnection({ iceServers: iceServers() });

    // Receber apenas vídeo
    transceiver = pc.addTransceiver('video', { direction:'recvonly' });
    preferVp8(transceiver);

    // eventos de estado para debug fino
    pc.oniceconnectionstatechange = ()=> setStatus(`ICE: ${pc.iceConnectionState}`);
    pc.onconnectionstatechange = ()=> setStatus(`PC: ${pc.connectionState}`);
    pc.onsignalingstatechange = ()=> console.debug('signaling:', pc.signalingState);

    pc.ontrack = (e)=>{
      const stream = (e.streams && e.streams[0]) ? e.streams[0] : new MediaStream([e.track]);
      if (video.srcObject !== stream) video.srcObject = stream;
      setStatus('Recebendo vídeo…');
      video.play().catch(()=>{});
    };

    pc.ondatachannel = (evt)=>{
      dc = evt.channel;
      dc.onopen  = ()=> setStatus('Conectado (canal de dados pronto)');
      dc.onclose = ()=> setStatus('Canal de dados fechado');
      dc.onmessage = (ev)=>{
        let obj = {}; try{ obj = JSON.parse(ev.data); }catch{}
        if(obj.t === 'ping') sendDc({ t:'pong' });
        else if(obj.t === 'status'){
          setStatus(`Status: ${obj.status}${obj.reason ? ' ('+obj.reason+')':''}`);
        }else if(obj.t === 'stats'){
          const { bytesSent, framesEncoded, fps, rttMs, qualityLimitation, encoderImpl } = obj;
          setStatus(`Stats – sent:${bytesSent}, frames:${framesEncoded}, fps:${fps ?? '-'}, rtt:${rttMs? rttMs.toFixed(0)+'ms':'-'}, qlim:${qualityLimitation ?? '-'}, enc:${encoderImpl ?? '-'}`);
        }
      };
    };

    pc.onicecandidate = (e)=>{
      if(!e.candidate) return;
      const payload = { room: currentSessionId, type:'ice', candidate: e.candidate };
      // envia nos dois formatos para garantir compatibilidade
      socket.emit('signal', payload);
      socket.emit('candidate', { room: currentSessionId, candidate: e.candidate });
    };
  }

  // Controles
  qLow.onclick  = ()=> sendDc({ cmd:'quality', level:'low'  });
  qMid.onclick  = ()=> sendDc({ cmd:'quality', level:'mid'  });
  qHigh.onclick = ()=> sendDc({ cmd:'quality', level:'high' });
  iceBtn.onclick   = ()=> sendDc({ cmd:'ice-restart' });
  statsBtn.onclick = ()=> sendDc({ cmd:'request-stats' });
  stopBtn.onclick  = ()=> sendDc({ cmd:'stop' });

  manualJoin.onclick = ()=>{
    const id = manualRoom.value.trim();
    if(!id) return alert('Informe o ID da sessão');
    startSession(id);
  };
  const fromSession = getParam('session');
  const fromRoom = getParam('room');
  if(fromSession) startSession(fromSession);
  else if(fromRoom) startSession(fromRoom);
  </script>
</body>
</html>
