<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ver Tela • Suporte X</title>

  <!-- Anti-cache extra no HTML -->
  <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="0" />

  <link rel="stylesheet" href="/style.css" />
  <style>
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap }
    .row button { padding:.5rem .8rem }
    video { width:100%; max-height:70vh; background:#000; }
    .muted { color:#888 }
  </style>
</head>
<body>
  <div class="card">
    <h1>Técnico: Ver Tela</h1>

    <div class="row">
      <input id="room" type="text" placeholder="Código da sessão (6 dígitos)" />
      <button id="join">Entrar</button>
    </div>

    <div class="row" style="margin-top:.5rem">
      <button id="qLow">Qualidade: Baixa</button>
      <button id="qMid">Qualidade: Média</button>
      <button id="qHigh">Qualidade: Alta</button>
      <button id="ice">Reiniciar ICE</button>
      <button id="stats">Stats</button>
      <button id="stop">Parar remoto</button>
    </div>

    <p class="muted">Dica: se recebeu um link com <code>?room=123456</code>, o código já será preenchido automaticamente.</p>
    <!-- muted ajuda o autoplay em todos os navegadores -->
    <video id="video" autoplay playsinline muted></video>
    <p class="muted" id="status">Aguardando…</p>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      const qs = (s) => document.querySelector(s);
      function getRoomFromQuery() {
        const u = new URL(location.href);
        return u.searchParams.get('room') || '';
      }

      const roomInput = qs('#room');
      const joinBtn   = qs('#join');
      const statusEl  = qs('#status');
      const video     = qs('#video');

      const qLow   = qs('#qLow');
      const qMid   = qs('#qMid');
      const qHigh  = qs('#qHigh');
      const iceBtn = qs('#ice');
      const statsBtn = qs('#stats');
      const stopBtn  = qs('#stop');

      // reforço de autoplay
      video.muted = true;
      video.addEventListener('loadedmetadata', () => video.play().catch(()=>{}));
      video.addEventListener('canplay',        () => video.play().catch(()=>{}));

      const roomFromURL = getRoomFromQuery();
      if (roomFromURL) roomInput.value = roomFromURL;

      let pc, socket, dc, videoTransceiver;

      function setStatus(msg){ statusEl.textContent = msg; }
      function iceServers(){
        return [{ urls: 'stun:stun.l.google.com:19302' }];
      }
      function sendDc(obj){
        if (dc && dc.readyState === 'open') dc.send(JSON.stringify(obj));
      }

      joinBtn.onclick = async () => {
        const room = roomInput.value.trim();
        if (!room) { alert('Informe o código da sessão'); return; }
        joinBtn.disabled = true; setStatus('Conectando…');

        // força WebSocket (menos latência que long-polling)
        socket = io({ transports: ['websocket'], upgrade: true });
        socket.emit('join', room);

        pc = new RTCPeerConnection({ iceServers: iceServers() });

        // Declarar recepção de vídeo (Unified Plan)
        videoTransceiver = pc.addTransceiver('video', { direction: 'recvonly' });

        // Preferir H.264 (normalmente dá menos uso de CPU em Android/iOS/Edge)
        try {
          const caps = RTCRtpReceiver.getCapabilities('video');
          if (caps && caps.codecs) {
            const h264 = caps.codecs.filter(c =>
              c.mimeType && c.mimeType.toLowerCase() === 'video/h264' &&
              (!c.sdpFmtpLine || c.sdpFmtpLine.includes('packetization-mode=1'))
            );
            if (h264.length) {
              const others = caps.codecs.filter(c => c.mimeType.toLowerCase() !== 'video/h264');
              videoTransceiver.setCodecPreferences([...h264, ...others]);
            }
          }
        } catch (e) { /* ok sem suporte */ }

        // Dica de baixa latência para o receptor (Chrome/Edge suportam)
        try {
          if (videoTransceiver?.receiver && 'playoutDelayHint' in videoTransceiver.receiver) {
            videoTransceiver.receiver.playoutDelayHint = 0.06; // ~60 ms
          }
        } catch (e) { /* ignora se não suportado */ }

        pc.ontrack = (e) => {
          const stream = (e.streams && e.streams[0]) ? e.streams[0] : new MediaStream([e.track]);
          if (video.srcObject !== stream) video.srcObject = stream;
          setStatus('Recebendo vídeo…');
          video.play().catch(()=>{});
        };

        pc.onicecandidate = (e) => {
          if (e.candidate) {
            socket.emit('signal', { room, type: 'ice', candidate: e.candidate });
          }
        };

        pc.onconnectionstatechange    = () => console.log('PC state:', pc.connectionState);
        pc.oniceconnectionstatechange = () => console.log('ICE state:', pc.iceConnectionState);

        pc.ondatachannel = (evt) => {
          dc = evt.channel;
          dc.onopen  = () => setStatus('Conectado (canal de dados pronto)');
          dc.onclose = () => setStatus('Canal de dados fechado');
          dc.onmessage = (ev) => {
            let obj = {};
            try { obj = JSON.parse(ev.data); } catch {}
            if (obj.t === 'ping') {
              sendDc({ t: 'pong' });
            } else if (obj.t === 'status') {
              setStatus(`Status: ${obj.status}${obj.reason ? ' ('+obj.reason+')' : ''}`);
            } else if (obj.t === 'stats') {
              const { bytesSent, framesEncoded, fps, rttMs } = obj;
              setStatus(`Stats – bytesSent: ${bytesSent}, frames: ${framesEncoded}, fps: ${fps ?? '-'}, rtt: ${rttMs ? rttMs.toFixed(0)+'ms' : '-'}`);
            }
          };
        };

        // Sinalização
        socket.on('signal', async (msg) => {
          if (!msg) return;

          if (msg.type === 'offer' && msg.sdp) {
            await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('signal', { room, type: 'answer', sdp: answer.sdp });
            setStatus('Conectado!');
          } else if (msg.type === 'ice' && msg.candidate) {
            try { await pc.addIceCandidate(msg.candidate); } catch (e) { console.error(e); }
          } else if (msg.candidate && msg.sdpMLineIndex !== undefined) {
            try { await pc.addIceCandidate(msg); } catch (e) { console.error(e); }
          }
        });

        socket.on('peer-left', () => setStatus('Cliente encerrou o compartilhamento.'));
      };

      // Controles
      qLow.onclick   = () => sendDc({ cmd: 'quality', level: 'low'  });
      qMid.onclick   = () => sendDc({ cmd: 'quality', level: 'mid'  });
      qHigh.onclick  = () => sendDc({ cmd: 'quality', level: 'high' });
      iceBtn.onclick = () => sendDc({ cmd: 'ice-restart' });
      statsBtn.onclick = () => sendDc({ cmd: 'request-stats' });
      stopBtn.onclick  = () => sendDc({ cmd: 'stop' });
    </script>
  </div>

  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/service-worker.js')
        .then(() => console.log('Service Worker registrado!'))
        .catch(err => console.error('Erro ao registrar SW:', err));
    }
  </script>
</body>
</html>
