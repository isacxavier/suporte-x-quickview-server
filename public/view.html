<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Painel de Atendimentos • Suporte_X</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
    :root{
      --brand:#FFCB19; --brandText:#111; --danger:#E63A3A; --muted:#6b7280;
      --bg:#F4F6F8; --card:#fff; --line:#E1E3E7; --blue:#0A84FF;
    }
    *{box-sizing:border-box}
    body{background:var(--bg); margin:0; font:14px/1.35 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Ubuntu}
    .grid{display:grid; grid-template-columns:360px 1fr; gap:1rem; align-items:start; padding:1.25rem}
    .card{background:var(--card); border:1px solid var(--line); border-radius:12px; padding:1rem; box-shadow:0 6px 18px rgba(16,24,40,.06)}
    .dot{width:10px;height:10px;background:#22C55E;border-radius:50%}
    .muted{color:var(--muted)}
    .row{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
    .btn{padding:.55rem .9rem; border-radius:10px; border:1px solid var(--line); background:#fff; cursor:pointer}
    .btn.primary{background:var(--brand); color:var(--brandText); border-color:var(--brand); font-weight:600}
    .btn.outline-blue{color:var(--blue); border-color:var(--blue); background:#fff}
    .btn.danger{background:var(--danger); color:#fff; border-color:var(--danger)}
    .pill{display:inline-block; padding:.15rem .5rem; border-radius:999px; background:#EEF1F5; font-size:.85rem}
    .list{display:flex; flex-direction:column; gap:.5rem}
    .request{display:flex; justify-content:space-between; gap:.5rem; align-items:center; padding:.6rem .6rem; border:1px solid var(--line); border-radius:10px; background:#fff; overflow:visible}
    .req-meta{display:flex; flex-direction:column}
    .req-actions{display:flex !important; gap:.4rem; align-items:center}
    .req-actions .btn{display:inline-flex !important; visibility:visible !important; opacity:1 !important; pointer-events:auto !important}
    video{width:100%; max-height:70vh; background:#000; border-radius:10px}
    details summary{cursor:pointer}
    code.pill{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
    .kbd{font:12px/1.2 ui-monospace,SFMono-Regular,Menlo,Consolas,monospace; background:#f3f4f6; border:1px solid #e5e7eb; padding:.1rem .35rem; border-radius:6px}
    .statusline{margin:.5rem 0 0; font-size:.95rem}
    input[type="text"], input[type="url"]{
      padding:.5rem .65rem; border:1px solid var(--line); border-radius:10px; flex:1 1 auto;
    }
    .small{font-size:.85rem}
    .tech-header-wrap{position:relative; margin-bottom:.75rem}
    .tech-header{display:flex; align-items:center; gap:.75rem}
    .tech-header-texts{display:flex; flex-direction:column; gap:.15rem}
    .tech-header-texts .name-row{display:flex; align-items:center; gap:.35rem}
    .avatar-button{width:44px; height:44px; border-radius:999px; border:none; background:#e5e7eb; display:inline-flex; align-items:center; justify-content:center; font-weight:600; color:#111; cursor:pointer; position:relative; overflow:hidden; transition:transform .2s ease}
    .avatar-button:hover{transform:scale(1.02)}
    .avatar-button:focus-visible{outline:2px solid var(--blue); outline-offset:2px}
    .avatar-button span{font-size:1rem}
    .avatar-button img{width:100%; height:100%; object-fit:cover; display:none}
    .avatar-button.has-photo img{display:block}
    .avatar-button.has-photo span{display:none}
    .avatar-menu{position:absolute; top:60px; left:0; background:var(--card); border:1px solid var(--line); border-radius:10px; box-shadow:0 12px 32px rgba(15,23,42,.16); padding:.35rem; min-width:160px; display:none; z-index:20}
    .avatar-menu.open{display:block}
    .avatar-menu button{width:100%; padding:.5rem .75rem; border:none; background:none; text-align:left; border-radius:8px; cursor:pointer; font:inherit; color:inherit}
    .avatar-menu button:hover{background:#f3f4f6}
    .switch{position:relative; display:inline-block; width:46px; height:26px}
    .switch input{opacity:0; width:0; height:0}
    .slider{position:absolute; cursor:pointer; top:0; left:0; right:0; bottom:0; background:#e5e7eb; border-radius:999px; transition:.2s}
    .slider:before{content:""; position:absolute; height:20px; width:20px; left:3px; top:3px; background:#fff; border-radius:50%; transition:.2s}
    .switch input:checked + .slider{background:#22C55E}
    .switch input:checked + .slider:before{transform:translateX(20px)}
    #autoSwitchLabel{margin-top:.15rem}
    #autoSwitchLabel.on{color:#15803d; font-weight:600}
    .pulse-border{animation:pulse 2s ease-out 1}
    @keyframes pulse{0%{box-shadow:0 0 0 0 rgba(255,203,25,.6);}100%{box-shadow:0 0 0 12px rgba(255,203,25,0);}}
  </style>
</head>
<body>
  <div class="grid">
    <!-- ESQUERDA: FILA + PERFIL -->
    <aside class="card">
      <div class="tech-header-wrap">
        <div class="tech-header">
          <button id="avatarButton" class="avatar-button" type="button" aria-haspopup="true" aria-expanded="false">
            <img id="avatarImage" alt="" hidden>
            <span id="avatarInitials">TX</span>
          </button>
          <div class="tech-header-texts">
            <div class="name-row">
              <strong id="techNameDisplay">Técnico</strong>
              <span class="dot" title="online"></span>
            </div>
            <span class="muted small" id="techStatusLabel">Disponível</span>
          </div>
        </div>
        <div id="avatarMenu" class="avatar-menu" role="menu" aria-hidden="true">
          <button type="button" id="editNameMenu" role="menuitem">Alterar nome</button>
        </div>
      </div>

      <div class="row" id="availabilityRow" style="margin-bottom:.25rem">
        <label class="muted small" style="flex:1">Painel de Atendimentos</label>
        <label class="switch">
          <input id="autoSwitch" type="checkbox" />
          <span class="slider"></span>
        </label>
      </div>
      <div class="small muted" id="autoSwitchLabel">ACEITAR CHAMADOS AUTOMATICAMENTE</div>
      <p class="muted" style="margin:.75rem 0 .75rem 0">Solicitações aguardando aceite.</p>

      <!-- Perfil do técnico -->
      <div class="row" style="margin-bottom:.5rem">
        <label for="techNameInput" class="muted small">Nome do técnico</label>
      </div>
      <div class="row" style="margin-bottom:.75rem">
        <input id="techNameInput" type="text" placeholder="Ex.: João (NOC)">
        <button id="saveTech" class="btn">Salvar</button>
      </div>

      <div class="row" style="justify-content:space-between; margin-bottom:.5rem">
        <span id="queueCount" class="pill">0 pendente(s)</span>
        <button id="refresh" class="btn">Atualizar</button>
      </div>

      <div id="queue" class="list">
        <div class="muted">Nenhuma solicitação por enquanto…</div>
      </div>

      <hr style="margin:1rem 0;border:none;border-top:1px solid var(--line)">

      <details>
        <summary class="muted">Debug / Entrada manual</summary>

        <div class="row" style="margin-top:.5rem">
          <input id="manualRoom" type="text" placeholder="sessionId (ou room antigo)" />
          <button id="manualJoin" class="btn">Entrar</button>
        </div>

        <div class="row" style="margin-top:.5rem">
          <input id="apiBase" type="url" placeholder="URL do servidor (API)" />
          <button id="saveApi" class="btn">Definir API</button>
        </div>

        <p class="muted small" style="margin-top:.3rem">
          Também funciona com <code>?session=XYZ</code> ou <code>?room=123456</code> na URL.
        </p>
      </details>
    </aside>

    <!-- DIREITA: RTC -->
    <main class="card">
      <h1 style="margin-top:0">Atendimento</h1>

      <div class="row" style="margin-bottom:.5rem">
        <span class="muted">Sessão atual:</span>
        <code id="sessionLabel" class="pill">—</code>
      </div>

      <div class="row" style="margin:.3rem 0 .7rem 0">
        <button id="qLow"  class="btn">Qualidade: Baixa</button>
        <button id="qMid"  class="btn">Qualidade: Média</button>
        <button id="qHigh" class="btn">Qualidade: Alta</button>
        <button id="ice"   class="btn">Reiniciar ICE</button>
        <button id="stats" class="btn">Stats</button>
        <button id="stop"  class="btn danger">Parar remoto</button>
      </div>

      <video id="video" autoplay playsinline muted></video>
      <p class="muted statusline" id="status">Aguardando…</p>
      <p class="muted small" id="serverLabel" style="margin:.25rem 0 0 0"></p>
    </main>
  </div>

  <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
  <script>
  // ================== CONFIG / PERFIL
  const DEFAULT_API = 'https://suporte-x-quickview-server.onrender.com';
  const getStored = (k, d='') => (localStorage.getItem(k) ?? d);
  const setStored = (k, v) => localStorage.setItem(k, v);

  // API base pode ser outro domínio. Se vazio => mesma origem.
  let API = getStored('apiBase', DEFAULT_API);
  const serverLabel = document.getElementById('serverLabel');
  function showServer(){ serverLabel.textContent = 'Servidor: ' + (API || location.origin); }
  showServer();

  // Nome do técnico (com campo na UI)
  let techName = (getStored('techName') || '').trim();
  const techNameInput = document.getElementById('techNameInput');
  const saveTech = document.getElementById('saveTech');
  if(!techName){ techName = prompt('Seu nome técnico?') || 'Técnico'; }
  techName = techName.trim();
  setStored('techName', techName);
  techNameInput.value = techName;
  saveTech.onclick = () => {
    const v = techNameInput.value.trim();
    if(!v) return alert('Informe um nome.');
    techName = v; setStored('techName', v);
    updateTechProfile();
    setStatus('Nome do técnico atualizado.');
  };

  // ================== UTIL
  const qs = (s) => document.querySelector(s);
  const apiFetch = (path, opts={}) => fetch((API || '') + path, opts);

  function getParam(name){
    const u = new URL(location.href);
    return u.searchParams.get(name) || '';
  }
  function fmtAgo(ts){
    try{
      const t = (typeof ts === 'string' && /^\d+$/.test(ts)) ? Number(ts) : Date.parse(ts) ? Date.parse(ts) : Number(ts);
      const diff = (Date.now() - t)/1000;
      if (diff < 60) return `${Math.floor(diff)}s`;
      if (diff < 3600) return `${Math.floor(diff/60)}m`;
      return `${Math.floor(diff/3600)}h`;
    }catch{ return ''; }
  }
  function setStatus(msg){ statusEl.textContent = msg; console.log('[STATUS]', msg); }
  function iceServers(){ return [{ urls: 'stun:stun.l.google.com:19302' }]; }

  // ================== ELEMENTOS
  const queueEl = qs('#queue');
  const queueCount = qs('#queueCount');
  const refreshBtn = qs('#refresh');
  const manualRoom = qs('#manualRoom');
  const manualJoin = qs('#manualJoin');
  const apiBaseInput = qs('#apiBase');
  const saveApiBtn   = qs('#saveApi');

  const video = qs('#video');
  const statusEl = qs('#status');
  const sessionLabel = qs('#sessionLabel');

  const qLow = qs('#qLow'), qMid = qs('#qMid'), qHigh = qs('#qHigh');
  const iceBtn = qs('#ice'), statsBtn = qs('#stats'), stopBtn = qs('#stop');
  const autoSwitch = qs('#autoSwitch');
  const autoSwitchLabel = qs('#autoSwitchLabel');
  const techNameDisplay = document.getElementById('techNameDisplay');
  const techStatusLabel = document.getElementById('techStatusLabel');
  const avatarButton = document.getElementById('avatarButton');
  const avatarImage = document.getElementById('avatarImage');
  const avatarInitials = document.getElementById('avatarInitials');
  const avatarMenu = document.getElementById('avatarMenu');
  const editNameMenu = document.getElementById('editNameMenu');
  const profileInfo = window.__profile || window.profile || {};
  const photoUrl = profileInfo?.photoUrl || '';

  let autoSwitchOn = false;
  let isAutoAccepting = false;
  let lastQueueList = [];
  let pc, socket, dc, transceiver;
  let currentSessionId = null;
  const earlyRemoteCandidates = [];
  let remoteDescSet = false;

  function computeInitials(name){
    if(!name) return 'TX';
    const parts = String(name).trim().split(/\s+/).filter(Boolean);
    if(!parts.length) return 'TX';
    const first = parts[0]?.[0] ?? '';
    const last = parts.length > 1 ? (parts[parts.length - 1]?.[0] ?? '') : '';
    const combo = (first + last).toUpperCase();
    if(combo.trim()) return combo;
    return parts[0].slice(0, 2).toUpperCase();
  }

  function updateTechProfile(){
    const displayName = techName || 'Técnico';
    if(techNameDisplay) techNameDisplay.textContent = displayName;
    if(techStatusLabel){
      if(currentSessionId){
        techStatusLabel.textContent = 'Em atendimento';
      }else{
        techStatusLabel.textContent = autoSwitchOn ? 'Aceitando automaticamente' : 'Disponível';
      }
    }
    if(avatarInitials) avatarInitials.textContent = computeInitials(displayName);
    if(photoUrl && avatarImage && avatarButton){
      avatarImage.src = photoUrl;
      avatarImage.alt = displayName;
      avatarImage.hidden = false;
      avatarButton.classList.add('has-photo');
    }else if(avatarImage && avatarButton){
      avatarImage.removeAttribute('src');
      avatarImage.alt = '';
      avatarImage.hidden = true;
      avatarButton.classList.remove('has-photo');
    }
  }

  function updateAutoLabel(){
    if(!autoSwitchLabel) return;
    autoSwitchLabel.textContent = autoSwitchOn ? 'ACEITANDO AUTOMATICAMENTE' : 'ACEITAR CHAMADOS AUTOMATICAMENTE';
    autoSwitchLabel.classList.toggle('on', !!autoSwitchOn);
  }

  function closeAvatarMenu(){
    if(avatarMenu){
      avatarMenu.classList.remove('open');
      avatarMenu.setAttribute('aria-hidden', 'true');
    }
    if(avatarButton){
      avatarButton.setAttribute('aria-expanded', 'false');
    }
  }

  if(autoSwitch){
    autoSwitch.checked = false;
    autoSwitchOn = false;
    updateAutoLabel();
    updateTechProfile();
    autoSwitch.addEventListener('change', () => {
      autoSwitchOn = autoSwitch.checked;
      updateAutoLabel();
      updateTechProfile();
      autoAssignIfIdle();
    });
  }else{
    updateTechProfile();
  }

  if(avatarButton){
    avatarButton.addEventListener('click', (ev) => {
      ev.stopPropagation();
      const expanded = avatarButton.getAttribute('aria-expanded') === 'true';
      const next = !expanded;
      avatarButton.setAttribute('aria-expanded', String(next));
      if(avatarMenu){
        avatarMenu.classList.toggle('open', next);
        avatarMenu.setAttribute('aria-hidden', String(!next));
        if(next){
          const firstBtn = avatarMenu.querySelector('button');
          firstBtn?.focus();
        }
      }
    });
  }

  document.addEventListener('click', (ev) => {
    if(!avatarMenu || !avatarMenu.classList.contains('open')) return;
    if(avatarButton && (ev.target === avatarButton || avatarButton.contains(ev.target))) return;
    if(avatarMenu.contains(ev.target)) return;
    closeAvatarMenu();
  });

  document.addEventListener('keydown', (ev) => {
    if(ev.key === 'Escape') closeAvatarMenu();
  });

  editNameMenu?.addEventListener('click', () => {
    closeAvatarMenu();
    techNameInput?.focus();
    techNameInput?.select();
  });

  // reforço autoplay
  video.muted = true;
  video.addEventListener('loadedmetadata', () => video.play().catch(()=>{}));
  video.addEventListener('canplay',        () => video.play().catch(()=>{}));

  // salvar/mostrar API base
  apiBaseInput.value = API;
  saveApiBtn.onclick = () => {
    const v = apiBaseInput.value.trim().replace(/\/+$/,'');
    API = v;
    setStored('apiBase', API);
    showServer();
    setStatus('API atualizada. Recarregue se for outro host.');
  };

  // ================== POLLING DA FILA
  async function fetchQueue(){
    try{
      const r = await apiFetch(`/api/requests?status=queued`, { headers: { 'accept':'application/json' }});
      if(!r.ok) throw new Error('HTTP '+r.status);
      const list = await r.json() || [];
      const prevLength = lastQueueList ? lastQueueList.length : 0;
      if(Array.isArray(list) && list.length > prevLength && !autoSwitchOn){
        queueEl?.classList.add('pulse-border');
        setTimeout(()=> queueEl?.classList.remove('pulse-border'), 2000);
      }
      lastQueueList = Array.isArray(list) ? [...list] : [];
      renderQueue(list);
      autoAssignIfIdle();
    }catch(e){
      console.debug('fetchQueue error', e);
    }
  }

  function renderQueue(items){
    queueEl.innerHTML = '';
    if(!items || !items.length){
      queueEl.innerHTML = `<div class="muted">Nenhuma solicitação por enquanto…</div>`;
      queueCount.textContent = `0 pendente(s)`;
      return;
    }
    queueCount.textContent = `${items.length} pendente(s)`;
    for(const it of items){
      const div = document.createElement('div');
      div.className = 'request';
      div.dataset.id = it.requestId;
      div.innerHTML = `
        <div class="req-meta">
          <strong>${it.brand ?? 'Dispositivo'} ${it.model ?? ''}</strong>
          <span class="muted">ID: ${it.requestId} • há ${fmtAgo(it.createdAt)}</span>
        </div>
        <div class="req-actions">
          <button class="btn outline-blue" type="button" data-act="reject" data-id="${it.requestId}">Recusar</button>
          <button class="btn primary"      type="button" data-act="accept" data-id="${it.requestId}">Aceitar</button>
        </div>`;
      queueEl.appendChild(div);
    }
  }

  async function autoAssignIfIdle(){
    if(!autoSwitchOn) return;
    if(currentSessionId) return;
    if(isAutoAccepting) return;
    const first = lastQueueList && lastQueueList[0];
    const requestId = first?.requestId;
    if(requestId){
      isAutoAccepting = true;
      try{
        await acceptRequest(requestId);
      }catch(err){
        console.warn('autoAssignIfIdle error', err);
      }finally{
        isAutoAccepting = false;
      }
    }
  }

  async function acceptRequest(id){
    const body = JSON.stringify({ techName });
    try{
      setStatus('Aceitando…');
      // rota padrão
      let r = await apiFetch(`/api/requests/${id}/accept`, {
        method:'POST',
        headers:{'content-type':'application/json','accept':'application/json'},
        body
      });

      // fallback para backends antigos (sem /accept)
      if(r.status === 404){
        console.warn('Fallback sem /accept');
        r = await apiFetch(`/api/requests/${id}`, {
          method:'POST',
          headers:{'content-type':'application/json','accept':'application/json'},
          body
        });
      }

      if(!r.ok) throw new Error('HTTP '+r.status);
      const { sessionId } = await r.json();
      if(!sessionId) throw new Error('Sem sessionId');
      startSession(sessionId);
      fetchQueue();
    }catch(e){
      console.error('Erro ao aceitar', e);
      setStatus('Falha ao aceitar: ' + e.message);
      alert('Erro ao aceitar: '+e.message);
    }
  }
  async function rejectRequest(id){
    try{
      await apiFetch(`/api/requests/${id}`, { method:'DELETE' });
      fetchQueue();
    }catch(e){}
  }

  queueEl.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button[data-act]');
    if(btn){
      const id = btn.getAttribute('data-id');
      const act = btn.getAttribute('data-act');
      if(act==='accept') acceptRequest(id);
      if(act==='reject') rejectRequest(id);
      return;
    }
    const card = ev.target.closest('.request');
    if(card && card.dataset.id){
      const id = card.dataset.id;
      card.style.opacity='0.6';
      card.style.outline='2px solid var(--brand)';
      acceptRequest(id);
    }
  });

  refreshBtn.onclick = fetchQueue;
  setInterval(fetchQueue, 2000);
  fetchQueue();

  // ================== RTC / SIGNALING
  function resetConnectionState(){
    remoteDescSet = false;
    earlyRemoteCandidates.length = 0;
    dc = null;
    transceiver = null;
  }

  function closeCurrent(){
    try{ if(pc) pc.close(); }catch(e){}
    try{ if(socket) socket.disconnect(); }catch(e){}
    pc = null; socket = null; resetConnectionState();
  }

  function setSessionLabel(id){ sessionLabel.textContent = id || '—'; }
  function sendDc(obj){ try{ if(dc && dc.readyState==='open') dc.send(JSON.stringify(obj)); }catch(e){} }

  function onSessionEnded(message){
    if(message) setStatus(message);
    closeCurrent();
    if(currentSessionId){
      currentSessionId = null;
      setSessionLabel('—');
    }
    autoAssignIfIdle();
    updateTechProfile();
  }

  function preferVp8(t){
    try{
      const caps = RTCRtpReceiver.getCapabilities('video');
      if(!caps || !t.setCodecPreferences) return;
      const pref = [...caps.codecs].sort((a,b)=>{
        const rank = (c)=> c.mimeType?.toLowerCase()==='video/vp8' ? 0
                       : c.mimeType?.toLowerCase()==='video/h264' ? 1 : 2;
        return rank(a)-rank(b);
      });
      t.setCodecPreferences(pref);
    }catch(e){}
  }

  function onAnySocketEvent(ev, ...args){
    console.debug('[socket]', ev, args?.[0]);
  }

  function normalizeSdpFrom(msg){
    if(!msg) return null;
    if(typeof msg === 'string') return msg;
    if(msg.sdp) return msg.sdp;
    if(msg.offer) return msg.offer;
    if(msg.description?.sdp) return msg.description.sdp;
    if(msg.payload?.sdp) return msg.payload.sdp;
    if(msg.desc?.sdp) return msg.desc.sdp;
    return null;
  }

  async function handleOfferMessage(raw){
    try{
      const sdp = normalizeSdpFrom(raw);
      if(!sdp){ console.warn('Offer sem SDP conhecida', raw); return; }
      await pc.setRemoteDescription({ type:'offer', sdp });
      remoteDescSet = true;
      setStatus('Offer recebida. Montando answer…');

      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);

      const payload = { room: currentSessionId, type:'answer', sdp: answer.sdp };
      socket.emit('signal', payload);
      socket.emit('answer', { room: currentSessionId, sdp: answer.sdp, type:'answer' });

      while(earlyRemoteCandidates.length){
        const c = earlyRemoteCandidates.shift();
        try{ await pc.addIceCandidate(c); }catch(err){ console.warn('Falha addIceCandidate (early)', err); }
      }

      setStatus('Conectado! (answer enviada)');
    }catch(e){
      console.error('Erro ao processar offer', e);
      setStatus('Erro ao processar offer');
    }
  }

  async function handleRemoteCandidate(obj){
    try{
      const c = obj?.candidate ? obj.candidate : obj;
      if(!c || (!c.candidate && c.candidate!=='')) return;

      if(!remoteDescSet){
        earlyRemoteCandidates.push(c);
        console.debug('ICE remoto guardado (antes da offer)');
      }else{
        await pc.addIceCandidate(c);
      }
    }catch(e){
      console.warn('Falha addIceCandidate', e);
    }
  }
    
// NOVO: fala várias "línguas" com o app/servidor ao entrar na sala
function announce(room){
  const payload = { room, session: room, sessionId: room, id: room, techName, role: 'tech' };
  ['join','join-room','subscribe','watch','viewer-join','support-join','tech-hello','ready','hello']
    .forEach(ev => socket.emit(ev, payload));
  // alguns backends escutam pelo nome da sala
  socket.emit(room, { t:'tech-joined', ...payload });
}
    // NOVO: pedir ao app para enviar a SDP offer (falamos vários "dialetos")
function requestOffer() {
  const base = { room: currentSessionId, session: currentSessionId, sessionId: currentSessionId, techName, role:'tech' };

  // eventos que diferentes apps/servidores costumam escutar
  const evs = [
    'need-offer','request-offer','send-offer','create-offer','offer?','rtc-offer?','sdp-offer?',
    'call','call-me','start','start-rtc','start-share','viewer-ready','watcher','ready-for-offer'
  ];
  evs.forEach(ev => socket.emit(ev, base));

  // e também em canais genéricos/room
  socket.emit('signal', { ...base, t:'need-offer' });
  socket.emit('webrtc', { ...base, t:'need-offer' });
  socket.emit(currentSessionId, { ...base, t:'need-offer' });
}
    
  function wireSocketHandlers(){
    socket.onAny(onAnySocketEvent);

    const onSignal = async (msg)=>{
      try{
        const t = (msg && (msg.type || msg.kind || msg.t || msg.event)) || '';
        if((t.toLowerCase() === 'offer') || (msg.offer) || (msg.description?.type==='offer') || (msg.payload?.type==='offer')){
          await handleOfferMessage(msg);
          return;
        }
        if(t.toLowerCase()==='ice' || t.toLowerCase()==='candidate' || msg.candidate || msg.ice){
          await handleRemoteCandidate(msg.candidate ? msg : (msg.ice ? msg.ice : msg));
          return;
        }
        if(msg.sdp && msg.type === 'offer'){
          await handleOfferMessage(msg);
          return;
        }
      }catch(e){ console.warn('onSignal error', e); }
    };

    socket.on('signal', onSignal);
    socket.on('webrtc', onSignal);
    socket.on('offer', handleOfferMessage);
    socket.on('app-offer', handleOfferMessage);
    socket.on('candidate', handleRemoteCandidate);
    socket.on('ice-candidate', handleRemoteCandidate);
    socket.on('app-candidate', handleRemoteCandidate);
    // ofertas em nomes alternativos
    socket.on('sdp-offer',     handleOfferMessage);
    socket.on('rtc-offer',     handleOfferMessage);
    socket.on('offer-created', handleOfferMessage);

    // ICE em nomes alternativos
    socket.on('ice',           handleRemoteCandidate);
    socket.on('iceCandidate',  handleRemoteCandidate);
    socket.on('rtc-ice',       handleRemoteCandidate);

    socket.on('peer-left', ()=> onSessionEnded('Cliente encerrou o compartilhamento.'));
    socket.on('connect_error', (e)=> setStatus('Socket erro: '+e.message));
    socket.on('disconnect', (r)=> console.debug('socket disconnect', r));
    
    // quando o app entra na sala, pedimos a offer
socket.on('peer-joined', (info) => {
  console.debug('peer-joined', info);
  setStatus('Cliente entrou. Solicitando offer…');
  requestOffer();
});

// alguns backends perguntam identidade antes de mandar a offer
socket.on('who-are-you', () => announce(currentSessionId));
socket.on('ready',        () => requestOffer());
socket.on('peer-ready',   () => requestOffer());
  }

  async function startSession(sessionId){
    closeCurrent();
    resetConnectionState();

    currentSessionId = sessionId;
    setSessionLabel(sessionId);
    setStatus('Conectando…');
    updateTechProfile();

    socket = io(API || undefined, { path:'/socket.io', transports:['websocket'], withCredentials:true });
    wireSocketHandlers();

// anuncia em vários formatos assim que conectar
socket.on('connect', () => {
  setStatus('Socket conectado');
  announce(sessionId);      // nos apresentamos (join, tech-hello, etc.)
  requestOffer();           // e já pedimos a offer
  // retry rápido caso o app demore um pouco para preparar a offer
  setTimeout(requestOffer, 500);
});

    // alguns backends perguntam antes
    socket.on('ready?', () => announce(sessionId));

    // e já tenta anunciar imediatamente também
    announce(sessionId);

    pc = new RTCPeerConnection({ iceServers: iceServers() });

    transceiver = pc.addTransceiver('video', { direction:'recvonly' });
    preferVp8(transceiver);

    pc.oniceconnectionstatechange = ()=> setStatus(`ICE: ${pc.iceConnectionState}`);
    pc.onconnectionstatechange = ()=>{
      const state = pc.connectionState;
      setStatus(`PC: ${state}`);
      if(['disconnected','failed','closed'].includes(state)){
        onSessionEnded();
      }
    };
    pc.onsignalingstatechange = ()=> console.debug('signaling:', pc.signalingState);

    pc.ontrack = (e)=>{
      const stream = (e.streams && e.streams[0]) ? e.streams[0] : new MediaStream([e.track]);
      if (video.srcObject !== stream) video.srcObject = stream;
      setStatus('Recebendo vídeo…');
      video.play().catch(()=>{});
    };

    pc.ondatachannel = (evt)=>{
      dc = evt.channel;
      dc.onopen  = ()=> setStatus('Conectado (canal de dados pronto)');
      dc.onclose = ()=> setStatus('Canal de dados fechado');
      dc.onmessage = (ev)=>{
        let obj = {}; try{ obj = JSON.parse(ev.data); }catch{}
        if(obj.t === 'ping') sendDc({ t:'pong' });
        else if(obj.t === 'status'){
          setStatus(`Status: ${obj.status}${obj.reason ? ' ('+obj.reason+')':''}`);
        }else if(obj.t === 'stats'){
          const { bytesSent, framesEncoded, fps, rttMs, qualityLimitation, encoderImpl } = obj;
          setStatus(`Stats – sent:${bytesSent}, frames:${framesEncoded}, fps:${fps ?? '-'}, rtt:${rttMs? rttMs.toFixed(0)+'ms':'-'}, qlim:${qualityLimitation ?? '-'}, enc:${encoderImpl ?? '-'}`);
        }
      };
    };

    pc.onicecandidate = (e)=>{
      if(!e.candidate) return;
      const payload = { room: currentSessionId, type:'ice', candidate: e.candidate };
      socket.emit('signal', payload);
      socket.emit('candidate', { room: currentSessionId, candidate: e.candidate });
    };
  }

  // Controles
  qLow.onclick  = ()=> sendDc({ cmd:'quality', level:'low'  });
  qMid.onclick  = ()=> sendDc({ cmd:'quality', level:'mid'  });
  qHigh.onclick = ()=> sendDc({ cmd:'quality', level:'high' });
  iceBtn.onclick   = ()=> sendDc({ cmd:'ice-restart' });
  statsBtn.onclick = ()=> sendDc({ cmd:'request-stats' });
  stopBtn.onclick  = ()=>{
    sendDc({ cmd:'stop' });
    onSessionEnded('Sessão encerrada.');
  };

  manualJoin.onclick = ()=>{
    const id = manualRoom.value.trim();
    if(!id) return alert('Informe o ID da sessão');
    startSession(id);
  };
  const fromSession = getParam('session');
  const fromRoom = getParam('room');
  if(fromSession) startSession(fromSession);
  else if(fromRoom) startSession(fromRoom);
  </script>
</body>
</html>
