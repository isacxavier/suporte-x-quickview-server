<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ver Tela • Suporte X</title>
  <link rel="stylesheet" href="/style.css" />
  <style>
    .row { display:flex; gap:.5rem; align-items:center; flex-wrap:wrap }
    .row button { padding:.5rem .8rem }
    video { width:100%; max-height:70vh; background:#000; }
    .muted { color:#888 }
  </style>
</head>
<body>
  <div class="card">
    <h1>Técnico: Ver Tela</h1>

    <div class="row">
      <input id="room" type="text" placeholder="Código da sessão (6 dígitos)" />
      <button id="join">Entrar</button>
    </div>

    <div class="row" style="margin-top:.5rem">
      <button id="qLow">Qualidade: Baixa</button>
      <button id="qMid">Qualidade: Média</button>
      <button id="qHigh">Qualidade: Alta</button>
      <button id="ice">Reiniciar ICE</button>
      <button id="stats">Stats</button>
      <button id="stop">Parar remoto</button>
    </div>

    <p class="muted">Dica: se recebeu um link com <code>?room=123456</code>, o código já será preenchido automaticamente.</p>
    <!-- muted ajuda o autoplay em todos os navegadores -->
    <video id="video" autoplay playsinline muted></video>
    <p class="muted" id="status">Aguardando…</p>

    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <script>
      const qs = (s) => document.querySelector(s);
      function getRoomFromQuery() {
        const u = new URL(location.href);
        return u.searchParams.get('room') || '';
      }

      const roomInput = qs('#room');
      const joinBtn = qs('#join');
      const statusEl = qs('#status');
      const video = qs('#video');

      const qLow = qs('#qLow');
      const qMid = qs('#qMid');
      const qHigh = qs('#qHigh');
      const iceBtn = qs('#ice');
      const statsBtn = qs('#stats');
      const stopBtn = qs('#stop');

      // reforço de autoplay
      video.muted = true;
      video.addEventListener('loadedmetadata', () => video.play().catch(()=>{}));
      video.addEventListener('canplay',        () => video.play().catch(()=>{}));

      const roomFromURL = getRoomFromQuery();
      if (roomFromURL) roomInput.value = roomFromURL;

      let pc, socket, dc, transceiver;

      function setStatus(msg){ statusEl.textContent = msg; }
      function iceServers(){
        return [{ urls: 'stun:stun.l.google.com:19302' }];
      }
      function sendDc(obj){
        if (dc && dc.readyState === 'open') dc.send(JSON.stringify(obj));
      }

      function preferVp8(t) {
        try {
          const caps = RTCRtpReceiver.getCapabilities('video');
          if (!caps || !t.setCodecPreferences) return;
          const pref = [...caps.codecs].sort((a,b) => {
            const rank = (c) => c.mimeType?.toLowerCase() === 'video/vp8' ? 0
                            : c.mimeType?.toLowerCase() === 'video/h264' ? 1 : 2;
            return rank(a) - rank(b);
          });
          t.setCodecPreferences(pref);
        } catch(e) { console.warn('codec pref not applied', e); }
      }

      joinBtn.onclick = async () => {
        const room = roomInput.value.trim();
        if (!room) { alert('Informe o código da sessão'); return; }
        joinBtn.disabled = true; setStatus('Conectando…');

        socket = io();              // mesma origem do server
        socket.emit('join', room);  // join simples (server aceita string)

        pc = new RTCPeerConnection({ iceServers: iceServers() });

        // RECEBER vídeo (Unified Plan) e preferir VP8 (casa melhor com Android)
        transceiver = pc.addTransceiver('video', { direction: 'recvonly' });
        preferVp8(transceiver);

        pc.ontrack = (e) => {
          const stream = (e.streams && e.streams[0]) ? e.streams[0] : new MediaStream([e.track]);
          if (video.srcObject !== stream) video.srcObject = stream;
          setStatus('Recebendo vídeo…');
          video.play().catch(()=>{});
        };

        pc.onicecandidate = (e) => {
          if (e.candidate) {
            socket.emit('signal', { room, type: 'ice', candidate: e.candidate });
          }
        };

        pc.onconnectionstatechange = () => console.log('PC state:', pc.connectionState);
        pc.oniceconnectionstatechange = () => console.log('ICE state:', pc.iceConnectionState);

        pc.ondatachannel = (evt) => {
          dc = evt.channel;
          dc.onopen = () => setStatus('Conectado (canal de dados pronto)');
          dc.onclose = () => setStatus('Canal de dados fechado');
          dc.onmessage = (ev) => {
            let obj = {};
            try { obj = JSON.parse(ev.data); } catch {}
            if (obj.t === 'ping') {
              sendDc({ t: 'pong' });
            } else if (obj.t === 'status') {
              setStatus(`Status: ${obj.status}${obj.reason ? ' ('+obj.reason+')' : ''}`);
            } else if (obj.t === 'stats') {
              const { bytesSent, framesEncoded, fps, rttMs, qualityLimitation, encoderImpl } = obj;
              setStatus(`Stats – sent: ${bytesSent}, frames: ${framesEncoded}, fps: ${fps ?? '-'}, rtt: ${rttMs ? rttMs.toFixed(0)+'ms' : '-'}, qlim: ${qualityLimitation ?? '-'}, enc: ${encoderImpl ?? '-'}`);
            }
          };
        };

        // Recebe do Android (offer/ice), já "desembrulhado" pelo servidor
        socket.on('signal', async (msg) => {
          if (!msg) return;

          if (msg.type === 'offer' && msg.sdp) {
            await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('signal', { room, type: 'answer', sdp: answer.sdp });
            setStatus('Conectado!');
          } else if (msg.type === 'ice' && msg.candidate) {
            try { await pc.addIceCandidate(msg.candidate); } catch (e) { console.error(e); }
          } else if (msg.candidate && msg.sdpMLineIndex !== undefined) {
            try { await pc.addIceCandidate(msg); } catch (e) { console.error(e); }
          }
        });

        socket.on('peer-left', () => setStatus('Cliente encerrou o compartilhamento.'));
      };

      // Controles
      qLow.onclick  = () => sendDc({ cmd: 'quality', level: 'low'  });
      qMid.onclick  = () => sendDc({ cmd: 'quality', level: 'mid'  });
      qHigh.onclick = () => sendDc({ cmd: 'quality', level: 'high' });
      iceBtn.onclick   = () => sendDc({ cmd: 'ice-restart' });
      statsBtn.onclick = () => sendDc({ cmd: 'request-stats' });
      stopBtn.onclick  = () => sendDc({ cmd: 'stop' });
    </script>
  </div>

  <!-- Removido o Service Worker para evitar cache antigo -->
  <!-- Se quiser manter SW depois, fazemos um SW "nocache" dedicado. -->

</body>
</html>
